---
title: "Motivational Scoring"
format: html
theme: lumen
---

`**As with all these scoring chunks, replace the df arguments with the relevant dfs. The ones here are from my testing**`

I make frequent use of sections. A fun tip for those reading in RStudio who don't know:

**Alt + O** will fold all sections, and **Shift + Alt + O** will expand all sections.

**Alt + L** will fold the current section, and **Shift + Alt + L** will expand it

necessary libraries and functions:

```{r, eval=FALSE}

library("dplyr")
library("stringr")

# this gets our scoring function

source("scoringFuns.R")

```

To see how our scoring function works, see scoringFuns.R, or the commenting in outcome_vars.qmd

## Social Desirability
Social Desirability uses our standard truth scoring scheme so we can use our funScore function.

```{r, eval=FALSE}
#first we specify cols to be reverse coded

sd_rev <- c("01", "03", "04", "05")

# this gets column names that starts with "sd_" and end with elements of sd_rev

sd_cols_rev <- paste0("sd_", sd_rev)

# this gets column names that start with "sd_" and *dont* end with elements of sd_rev

sd_cols <- colnames(df %>%
  select(starts_with("sd_")) %>%
  select(-ends_with((sd_rev))))

# run the function, code the vars! 
# we run it twice, once with reverse set FALSE for the non reversed columns, and once with reverse set TRUE for reverse scored columns


df1 <- funScore(df, sd_cols, "agreement", FALSE)
df2 <- funScore(df1, sd_cols_rev, "agreement", TRUE)

```

## Existential Security

Existential Security questions are scored on our frequency scale and on our agreement scale. So we use funScore.

```{r, eval=FALSE}

#es_ questions are scored on our frequency scale

es_cols <- colnames(df %>%
  select(starts_with("es_")))

#our other security measures are on our agreement scale

es_cols1 <- colnames(df %>%
  select(starts_with(c("ss_", "wi_", "st_"))))

# no items are reverse coded so we just run funScore once for both, with reverse set to FALSE

# run the function, code the vars!

df1 <- funScore(df, es_cols,  "frequency", FALSE)
df1 <- funScore(df, es_cols1, "agreement", FALSE)


```

## Need for Structure

```{r, eval=FALSE}

nfs_rev <- c("02", "05", "06", "11")

nfs_cols_rev <- paste0("sd_", nfs_rev)


nfs_cols <- colnames(df %>%
  select(starts_with("nfs_")) %>%
  select(-ends_with((nfs_rev))))


df1 <- funScore(df, nfs_cols, "agreement", FALSE)
df2 <- funScore(df1, nfs_cols_rev, "agreement", TRUE)
```

## Death Anxiety

```{r, eval=FALSE}

da_cols <- colnames(df %>%
  select(starts_with("da_")))

df1 <- funScore(df, nfs_cols_rev, "agreement", TRUE)
```

## Social Network Size

Responses here are a list of initials, preferably split by a comma.

We need to check how the data actually looks...

First we check to see if any responses uses any other punctuation other than comma...

```{r, eval=FALSE}



# here we pass the anonymous function across all elements of sns_01, and put the outcomes (TRUE/FALSE) into a new column sns_punct

# str_detect("[[:punct:]&&[^,]]" checks if any punctuation *other* than a comma is used

df <- df %>%
  mutate(sns_punct = sapply(sns_01, function(pnct) {
    any(str_detect(pnct, "[[:punct:]&&[^,]]"))  
  }))


# We then look to see what these cases look like

df_inspect <- df %>%
  filter(
    sns_punct == TRUE
  )

# we can create a new column that replaces any punctuation other than a comma with a comma if this is needed

df <- df %>%
  mutate(sns_replaced = str_replace_all(sna_01, "[[:punct:]&&[^,]]", ","))


# if we need to do this with a space as a possible separator too.

df <- df %>%
  mutate(sns_replaced = str_replace_all(sns_01, "[[:punct:]&&[^,\\s]]", ","))


```

Ok, assuming we now have a column where elements are separated by a comma we move on...

We use sns_01 here assuming no changes were needed in the prior chunk, but switch the varname if needed.

```{r, eval=FALSE}


#now we create a new column sns_lst, which splits the column by comma..

df <- df %>%
  mutate(sns_lst = strsplit(sns_01, ", "))

# we now check if there are any spaces in any elements of this (if there is we may need to back and add a space to the last part of the last chunk)

df <- df %>%
  mutate(sns_spaces = sapply(sns_lst, function(spcs) {
    any(str_detect(spcs, " "))
  }))

# now we check if any elements of this are longer than 3 (might indicate names)

df <- df %>%
  mutate(sns_lngth = sapply(sns_lst, function(lngth) {
    any(nchar(lngth) > 3)
  }))



```

**Here is where we have to use our big wrinkly brains and figure out if our data is analysable yet...**

if so we use this

```{r, eval=FALSE}

# this creates a new column sns_num which counts the number of elements of sns_lst

df <- df %>%
  mutate(sns_num = lengths(sns_lst))

```

## Need for Meaning

The Need for Meaning questionnaire has agreement responses, and the Meaning in Life questionnaire has truth responses. We therefore use our funScore for both.

### Meaning in Life:

```{r, eval=FALSE}

#reverse items

mlq_rev <- c("01", "04", "05", "06",  "09")

mlq_cols_rev <- paste0("mlq_", sd_rev)

mlq_cols <- colnames(df %>%
  select(starts_with("mlq_")) %>%
  select(-ends_with((mlq_rev))))


df1 <- funScore(df, mlq_cols, "agreement", FALSE)
df2 <- funScore(df1, mlq_cols_rev, "agreement", TRUE)


```

### Need for Meaning

```{r, eval=FALSE}

#reverse items

nfm_rev <- c("01", "03", "07")

nfm_cols_rev <- paste0("nfm_", sd_rev)

nfm_cols <- colnames(df %>%
  select(starts_with("nfm_")) %>%
  select(-ends_with((nfm_rev))))


df1 <- funScore(df, nfm_cols, "agreement", FALSE)
df2 <- funScore(df1, nfm_cols_rev, "agreement", TRUE)



```


## Digust  Sensitivity

Disgust sensitivity has two response schemes, half are yes/no, the other half a bespoke  scheme.

**Yes/No items**

Disgust Sensitivity has a unique scoring scheme for yes/no items


```{r}

```

**Disgust items**

These also have a unique level structure and scoring scheme

```{r, eval=FALSE}

```

