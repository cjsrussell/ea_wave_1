---
title: "Cognitive Styles Scoring"
format: html
theme: lumen
---

### necessary libraries and functions

```{r}

library("dplyr")

getwd()

source("../scoringFuns.R")

#load df (i forgot to hide row names when writing csv hence select -x )

df <- read.csv("sim_testingdata/cogstyle_testdat.csv ") %>% select(-X)

# create duplicate df for comparison

df_test <- df %>%
  rename_all(~ paste0(., "_c"))

```


## Tolerance of Ambiguity

```{r}
#first we specify cols to be reverse coded

at_rev <- c("01", "02", "03",  "04", "05", "06", "09", "11", "12")

at_cols_rev <- paste0("at_", at_rev)

at_cols <- colnames(df %>%
  select(starts_with("at_")) %>%
  select(-ends_with((at_rev))))

# code!

df <- funScore(df, at_cols, "agreement", FALSE)
df <- funScore(df, at_cols_rev, "agreement", TRUE)

```

We can create a subset of this to check the coding

```{r}

# we will use 09, 10, 11, 12, 13 to be able toc heck reverse and non reverse coded cols


at_df <- cbind(df %>% select(starts_with("at_") &
                             ends_with(c("09", "10", "11", "12", "13"))),
               df_test %>% select(starts_with("at_") &
                             ends_with(c("09_c", "10_c", "11_c", "12_c", "13_C")))
)


# we can now look at df_ic and see if everything is correct.

# As odd and even columns have opposite response orders, we should expect an even column and a reverse scored odd column to be scored the same

# 09, 11, 12 are reverse coded here, so:

# 9 and 10 should have the same code, as they have opposite raw data, but only 9 is reverse coded

# and 11 and 12 should have different code as both are reverse coded and both have different raw data

# Luckily this is what we see!
```


## Thinking Style

Thinking style variables are coded as correct or incorrect

!! I can't anticipate all responses so I will code this properly when we have the data and all of the responses given!!

!!not tested or simulated - this is an example!!

```{r, eval = FALSE}

# remove eval = FALSE  when actually using!


#check the different responses given:

unq_resp_ts_01 <- unique(df$ts_01)

correct_ts01 <- c("Second",
                   "second",
                   "secnd",
                   "2nd")
    
df <- df %>%
  mutate(
    
    #specify column
    
    ts_01 = case_when(
      
      #specify that if the element in the column is in  corerct_ts01 then it is a 1, and if not it is a 0
      
      . %in% correct_ts01 ~ 1,
      TRUE ~ 0),
    
    ts_02 = case_when(
      . %in% correct_ts02 ~ 1,
      
      TRUE ~ 0),
    ts_03 = case_when(
      . %in% correct_ts03 ~ 1,
      
      TRUE ~ 0),
    ts_04 = case_when(
      . %in% correct_ts04 ~ 1,
      
      TRUE ~ 0),
    ts_05 = case_when(
      . %in% correct_ts05 ~ 1,
      
      TRUE ~ 0),
    ts_06 = case_when(
      . %in% correct_ts06 ~ 1,
      TRUE ~ 0)
  )

```


## Non-verbal Reasoning 

Non-verbal uses a unique scoring scheme

## Moralisation of Rationality

Moralisation of Rationality items use the standard scoring scheme so we can use the funScore function

```{r}

# no reverse coding

mor_cols <- colnames(df %>%
  select(starts_with("mor_")))

# code!

df <- funScore(df, mor_cols, "agreement", FALSE)


```


We can create a subset of this to check the coding

```{r}

mor_df <- cbind(df %>% select(starts_with("mor_") &
                             ends_with(c("01", "02", "03", "04"))),
               df_test %>% select(starts_with("mor_") &
                             ends_with(c("01_c", "02_c", "03_c", "04_c")))
)
```

## Importance of Rationality

```{r}

# no reverse coding

imp_cols <- colnames(df %>%
  select(starts_with("imp_")))

# code!

df <- funScore(df, imp_cols, "agreement", FALSE)


```

Check the coding

```{r}

imp_df <- cbind(df %>% select(starts_with("imp_") &
                             ends_with(c("01", "02", "03", "04"))),
               df_test %>% select(starts_with("imp_") &
                             ends_with(c("01_c", "02_c", "03_c", "04_c")))
)
```